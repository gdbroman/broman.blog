---
title: 'How I learned software engineering'
date: '2022-05-14'
---

I was 13 years old and no one in my family knew how to code. None of my friends knew what it was. But I was lucky enough to get my hands on a computer at this age.

The reason why I got a computer was that my parents felt bad for me. I had informed them of how "every friend at school had an Xbox." The half-lie worked, and for my birthday, my parents gave me a personal computer. *"Even better than Xbox,"* they said. It was cheaper of course. But I can’t complain, because as you might have guessed, this cheap PC led me to programming.

<Image src="/images/software/old.webp" alt="Old computer" />

The games this fat Dell computer could handle were embarrassingly bad. So pretty quickly, the idea of creating my own game was planted in my mind.

There was one game I loved however: it was called Flyff. It was a massively multiplayer RPG; like a free, Asian alternative to World of Warcraft. My computer could barely start the thing of course. *What if I could create my own Flyff which my computer could handle?*

So I started googling. But I struggled; there were barely any resources in my mother tongue, and my English wasn’t good. But eventually, I came across something called C++. Apparently, all the best games—including Flyff—were written in it. Bingo.

## Year 1: C++

So during summer break, I started watching YouTube tutorials by [thenewboston](https://www.youtube.com/user/thenewboston). He'd always start with *“What’s up guys, Bucky here.”* Turns out he's still making videos!

I remember those summer mornings. I'd wake up early, make coffee, bring it to my room, boot up the fat computer. Netbeans on the one side of the screen, thenewboston's C++ playlist on the other. I was ecstatic.

And after two weeks of hard work, I had scraped together a barely functioning calculator. On the one hand, I was proud, on the other, I was realizing how far away I was from creating Flyff. Furthermore, even Bucky—the man himself—didn’t seem capable of writing anything close to a massively multiplayer RPG (or why hadn't he?). So reality was catching up, and I was feeling discouraged.

In hindsight, C++ is maybe not the best language to start with. If you're wondering where to start, I'd recommend a high-level language instead, like Python or JavaScript. But I'd also say, **whatever language gets you started is the language for you.**

## Year 2: Java Swing Applets

Fast forward two years and I'm in high school. I'm 15 years old and taking one of the few programming classes my school had to offer. It was in Java.

<Image src="/images/software/swingraphics.jpeg" alt="Java swing graphics" />

My desire to create games was still alive. So I started out creating simple text-based console games, and then moved over to graphical games using the Swing package—like Snake and Pong. I wasn't a big fan of Java's verbose and boilerplate nature, but my old dream of creating an RPG was now considerably closer.

And then, because I was really into math at the time, I got into using Java for numerical problem-solving on [projecteuler.net](https://projecteuler.net). Project Euler is like the godfather of LeetCode, except it's for fun instead of job interviews.

## Year 3: Web Dev! HTML, CSS, jQuery

In high school, I also took a web development course, where I learned HTML, CSS, and jQuery. This I loved even more than Java.

A new hobby of mine became copying website designs. I distinctly remember recreating SpaceX's landing page. I also learned about design frameworks like Google's material design.

I found this more enjoyable than previous programming because it was more visual. Takeaway: **Keep trying different kinds of programming until you find one that resonates with you.**

## Year 4: Battlebot

Last year of high school, together with my classmate, I built a remote-controlled battlebot using Arduino and 10kg of metal. Check out the spinning blade peeking out underneath.

<Image src="/images/software/battlebot.jpg" alt="Remote-controlled battlebot" />

If you don't know, Arduino is a bit like Raspberry Pi. A small computer, programmable with C++ (which was nostalgic for me).

The construction turned out a bit too heavy for the motors, resulting in bad mobility. But the spinning blade was a great success (no fingers lost).

## Year 5: PHP and SQL

At 18 years old, I enrolled in university to study physics. I chose physics because it seemed more evergreen than computer science. I have changed my mind about this since. But at this time, I also still wasn't entirely sure if programming was for me, so physics seemed like a more diversified bet.

The first year, the only programming we did was one class in Python, and one numerical analysis class, using Matlab. So after my first year in university, I was craving web development. More specifically, I was longing for that creative process I had experienced when I was copying website designs back in high school. Furthermore, I wanted to make money. I was sick of being a broke student.

I decided I was going to build a SaaS app, which I'd charge people money for. I had no idea how to achieve this with the sparse jQuery knowledge I had, so once again, I started googling. And I found a full-stack YouTube tutorial by [Will Kwan](https://www.youtube.com/watch?v=HmyMFZQDWyU), which used NodeJS and MongoDB for the backend and EJS for the frontend. That was a few too many new technologies for me at the time, so I resorted to learning PHP and SQL instead.

Beginning my second year of university, I had finished the first version of a marketplace app. So not quite SaaS, but it had authentication, profiles, and everything. The product was shit. The world didn't need another marketplace app. And when the app didn't make me any money, I realized I was going to have to get a job. For now.

## Year 6: React

Problem is, you can't get a job knowing some PHP and Python. All the cool companies use frontend frameworks. I learned this the hard way by answering "jQuery" upon being asked what framework I preferred in my first interview. Needless to say, they never got back.

After that embarrassing experience, I started learning React. It was pretty tough, and I underestimated how long I would be learning it for. Two years later, I'm still learning.

Luckily, I connected with someone on LinkedIn who was also trying to learn React. We had coffee, became friends, and built some projects together—some of which made money.

<Image src="/images/software/ui.png" alt="Remote-controlled battlebot" />

That summer, I ended up with an internship, and subsequently landing my first full-time job. It was at a venture-funded startup, I had to learn React Native on the job, and I was 21. I was finally earning a sizable income from programming, and it felt great. Takeaway: **If you want rapid progress, get a learning buddy, and build projects together.**

## Year 7: Advanced Javascript

After landing my first job, I felt like I was stagnating. Every time I ran into a bug I resorted to Stack Overflow. I wasn't a mature enough developer to do debugging on my own. I realized that my weak point was pure JavaScript. I knew React, but not what was happening under the hood.

So I took an [advanced JS course](https://www.udemy.com/course/understand-javascript), which taught me about the event loop, hoisting, execution contexts, and how all of the different primitives differed. This was exceptionally fruitful, because that course took like a week for me to do. But it *leveled me up.*

And because I had some experience writing React apps, I had context to fit this new theoretical knowledge into. This is critical. Had I taken it earlier, it would have went over my head. **Taking courses successfully is 90% about timing, and thus being self-aware about what to take and when.**

After that week of studying, I started interviewing. I got a handful of offers, and eventually chose the job I now have, writing React in the frontend. Finally, I could confidently claim to be a decent developer. So much so, I decided to not return to university; because I had proven to myself: I could learn on my own.

## Year 8: Style and Performance

In the new job, I found myself in a team with more experienced engineers, so I started to expand my thinking about code to more than mere syntax. *How do you collaborate on code effectively? How do you write code that is performant yet maintainable?*

<Image src="/images/software/pragprog.jpg" alt="The Pragmatic Programmer by Andrew Hunt" />

I read Clean Code by Robert Martin and [The Pragmatic Programmer](/pragprog) by Andrew Hunt. I also took some Udemy courses in computer science, on data structures and algorithms.

This was a period where my perception of programming expanded. For instance, I realized **there are no straight answers to what the best design pattern is, only different philosophies with different tradeoffs.** My appreciation for the craft grew.

## Year 9: Kubernetes

At my current job, I got offered to join our on-call rotation. For the uninitiated, on-call basically means you are delegated more responsibility to make sure all systems are kept up and running.

Thing is, I didn’t know any Kubernetes. And to be a good on-caller you have to know Kubernetes. So once again, I took a [Udemy course](https://www.udemy.com/course/learn-kubernetes). Meta note here: this is the best kind of learning you’ll ever do—when circumstances force you to.

**So if you're feeling stagnant, put yourself in a sink or swim situation.** I would not have learned Kubernetes if I didn't.
